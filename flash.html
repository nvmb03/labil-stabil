<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash | Labil‚ÄìStabil</title>
    
    <!-- p5.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        if (typeof p5 === 'undefined') {
            document.write('<script src="p5.min.js"><\/script>');
        }
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Space Mono', monospace;
            background: #ffebeb;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        
        /* Icons */
        .icon-button {
            position: fixed;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 1000;
            text-decoration: none;
            backdrop-filter: blur(10px);
        }
        
        .icon-button:hover {
            background: rgba(220, 20, 60, 0.9);  /* Crimson Red */
            border-color: #DC143C;
            transform: scale(1.1);
        }
        
        #backButton {
            top: 20px;
            left: 20px;
        }
        
        #infoButton {
            top: 20px;
            right: 20px;
        }
        
        /* Info Panel */
        #infoPanel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 350px;
            max-height: calc(100vh - 120px);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #DC143C;  /* Crimson Red */
            border-left: 4px solid #DC143C;
            padding: 25px;
            color: #fff;
            backdrop-filter: blur(10px);
            z-index: 999;
            overflow-y: auto;
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #infoPanel.active {
            transform: translateX(0);
            opacity: 1;
        }
        
        #infoPanel h1 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #DC143C;  /* Crimson Red */
            letter-spacing: 2px;
        }
        
        #infoPanel h2 {
            font-size: 14px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #FF8C00;  /* Dark Orange */
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #infoPanel p {
            font-size: 12px;
            line-height: 1.7;
            opacity: 0.9;
            margin-bottom: 12px;
        }
        
        #infoPanel strong {
            color: #DC143C;  /* Crimson Red */
        }
        
        #infoPanel ul {
            list-style: none;
            padding-left: 0;
            margin-bottom: 15px;
        }
        
        #infoPanel li {
            font-size: 11px;
            line-height: 1.6;
            padding: 6px 0;
            padding-left: 20px;
            position: relative;
            opacity: 0.85;
        }
        
        #infoPanel li:before {
            content: "‚Üí";
            position: absolute;
            left: 0;
            color: #DC143C;  /* Crimson Red */
        }
        
        /* Scrollbar styling */
        #infoPanel::-webkit-scrollbar {
            width: 6px;
        }
        
        #infoPanel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        #infoPanel::-webkit-scrollbar-thumb {
            background: #DC143C;  /* Crimson Red */
            border-radius: 3px;
        }
        
        /* Animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .icon-button {
            animation: fadeIn 0.5s ease-out;
        }
        
        #backButton {
            animation-delay: 0.1s;
        }
        
        #infoButton {
            animation-delay: 0.2s;
        }
    </style>
</head>
<body>
    <!-- Back Button -->
    <a href="index.html" class="icon-button" id="backButton" title="Zur√ºck zum Men√º">
        ‚Üê
    </a>
    
    <!-- Info Button -->
    <div class="icon-button" id="infoButton" title="Informationen">
        i
    </div>
    
    <!-- Info Panel -->
    <div id="infoPanel">
        <h1>FLASH</h1>
        
        <p><strong>Neurodivergenz:</strong> Entscheidungsparalyse</p>
        
        <h2>Mechanik</h2>
        <ul>
            <li>Z√∂gern (0.5 Sek) ‚Üí √úberlegt...</li>
            <li>Aufladen (1.5 Sek) ‚Üí Denkt nach, langsame Rotation</li>
            <li>Dash zur Maus ‚Üí Aber oft zu sp√§t oder falsch</li>
            <li>50% Fail: Stolpern oder Rutschen</li>
        </ul>
        
        <h2>Nach Fail</h2>
        <ul>
            <li>Liegt frustriert (1 Sek)</li>
            <li>Dreht sich langsam aus</li>
            <li>Steht langsam auf (0.5 Sek)</li>
            <li>Sch√ºttelt Kopf langsam (0.75 Sek)</li>
            <li>Still w√ºtend (0.75 Sek)</li>
            <li>Lange Pause (1.5 Sek) ‚Üí √úberlegt wieder...</li>
        </ul>
        
        <h2>Tragik</h2>
        <p>Flash denkt blitzschnell und sieht alle Wege gleichzeitig. Im entscheidenden Moment l√§hmt ihn genau diese Geschwindigkeit ‚Äì zu viele Optionen, keine Entscheidung. Geschwindigkeit ohne Richtung ist Stillstand.</p>
    </div>

    <script>
        // Info Panel Toggle
        const infoButton = document.getElementById('infoButton');
        const infoPanel = document.getElementById('infoPanel');
        
        infoButton.addEventListener('click', () => {
            infoPanel.classList.toggle('active');
        });
        
        // Schlie√üen wenn au√üerhalb geklickt
        document.addEventListener('click', (e) => {
            if (!infoPanel.contains(e.target) && e.target !== infoButton) {
                infoPanel.classList.remove('active');
            }
        });
    </script>

    <script>
        // ============================================================================
        // FLASH - Der Speedster-Stern (Python-Version √ºbersetzt zu JavaScript)
        // Signatur: Aufladen (Morphing) ‚Üí Explosiver Dash ‚Üí Bounce ‚Üí Friction
        // ============================================================================

        // Position
        let x, y;
        
        // Stern-Form Parameter - 5-Zacken wie Spider-Man & Superman!
        const points = 5;  // 4 ‚Üí 5 Zacken!
        const base_outer = 30.0;  // 50 ‚Üí 30 (gleiche Gr√∂√üe wie Spider-Man!)
        const base_inner = 12.0;  // 15 ‚Üí 12 (Verh√§ltnis wie Spider-Man: 0.4)
        let outer_radius = base_outer;
        let inner_radius = base_inner;
        // KEINE VARIATION - perfekt symmetrisch!
        let offsets = [];
        
        // State Management
        let state = "idle";
        let state_timer = 0;
        const charge_duration = 40;  // 60 ‚Üí 40 (schneller aufladen!)
        
        // Rotation
        let rotation = 0.0;
        let rotation_speed = 0.0;
        
        // Bewegung
        let vx = 0.0;
        let vy = 0.0;
        const dash_speed = 60.0;  // 45 ‚Üí 60 (schneller!)
        const friction = 0.91;  // 0.82 ‚Üí 0.91 (doppelte Dash-L√§nge!)
        
        // Morphing beim Aufladen
        let target_outer = base_outer;
        let target_inner = base_inner;
        const morph_speed = 0.12;
        
        // Trail f√ºr Motion Blur
        let trail_positions = [];
        
        // Fail-States
        let fail_type = null;  // "stumble" oder "slip"
        let fail_timer = 0;
        let shake_start_rotation = 0.0;  // Speichert Rotation beim Start des Shakings
        let fail_direction = 0.0;
        let slip_offset = 0.0;  // F√ºr Cartoon-Slip Rotation
        let squash_amount = 1.0;  // F√ºr Plumpsen (Gr√∂√üen-Multiplikator)
        let anger_particles = [];  // Rote Silhouetten bei Frust

        function setup() {
            createCanvas(windowWidth, windowHeight);
            x = width / 2;
            y = height / 2;
            
            // PERFEKT SYMMETRISCH - keine random Offsets!
            for (let i = 0; i < points * 2; i++) {
                offsets.push(0);  // Alle Offsets = 0 f√ºr perfekte Symmetrie!
            }
        }

        function draw() {
            background(245, 245, 245);  // Helles Grau - Stadt-Feeling
            
            updateFlash();
            displayFlash();
        }

        function updateFlash() {
            if (state === "idle") {
                state_timer++;
                
                // KURZE Pause - SCHNELLER!
                if (state_timer >= 15) {  // War 20 ‚Üí jetzt 15 (0.25 Sek)
                    startCharging();
                }
            }
            else if (state === "charging") {
                state_timer++;
                
                // ANLAUF-ANIMATION: Wie einen Bogen spannen! üèπ
                // Phase 1 (erste H√§lfte): Zur√ºckdrehen & Zur√ºckziehen
                // Phase 2 (zweite H√§lfte): Bereit zum Schuss
                
                let charge_progress = state_timer / charge_duration;
                
                // Berechne Richtung ENTGEGENGESETZT zur Maus!
                let dx_to_mouse = mouseX - x;
                let dy_to_mouse = mouseY - y;
                let dist = Math.sqrt(dx_to_mouse * dx_to_mouse + dy_to_mouse * dy_to_mouse);
                
                if (dist > 10) {  // Nur wenn Maus nicht zu nah
                    let dir_x = dx_to_mouse / dist;
                    let dir_y = dy_to_mouse / dist;
                    
                    if (charge_progress < 0.6) {
                        // Phase 1: WINDUP - Dreht R√úCKW√ÑRTS & BEWEGT sich R√úCKW√ÑRTS!
                        let windup_progress = charge_progress / 0.6;  // 0 bis 1
                        
                        // Rotation r√ºckw√§rts
                        rotation_speed = -0.12 * (1 - windup_progress);
                        rotation += rotation_speed;
                        
                        // POSITION: Bewegt sich ENTGEGENGESETZT zur Maus!
                        // Maximum bei 50% der windup phase
                        let pullback_amount = Math.sin(windup_progress * PI) * 15;  // REDUZIERT: 25 ‚Üí 15 Pixel!
                        x -= dir_x * pullback_amount * 0.10;  // REDUZIERT: 0.15 ‚Üí 0.10
                        y -= dir_y * pullback_amount * 0.10;
                        
                    } else {
                        // Phase 2: READY - Langsam vorw√§rts drehen (Position bleibt)
                        let ready_progress = (charge_progress - 0.6) / 0.4;
                        rotation_speed = 0.08 * ready_progress;
                        rotation += rotation_speed;
                    }
                }
                
                // Charging abgeschlossen?
                if (state_timer >= charge_duration) {
                    startDash();
                }
            }
            else if (state === "dashing") {
                // STUMBLE-CHECK: Stolpert nach X Frames?
                if (fail_type === "stumble" && fail_timer > 0) {
                    fail_timer--;
                    if (fail_timer === 0) {
                        // STOLPERN! Geschwindigkeit drastisch reduzieren
                        vx *= 0.3;
                        vy *= 0.3;
                        // Weiter dashing, bremst nat√ºrlich ab
                        fail_type = "stumbled";  // Markiere als gestolpert
                    }
                }
                
                // Bewegung
                x += vx;
                y += vy;
                
                // Trail aufbauen (nur alle 2 Frames)
                if (frameCount % 2 === 0) {
                    trail_positions.push({
                        x: x,
                        y: y,
                        life: 15,
                        rotation: rotation
                    });
                }
                
                // Wand-Kollision (Bounce)
                let bounced = false;
                if (x < outer_radius) {
                    x = outer_radius;
                    vx = Math.abs(vx);
                    bounced = true;
                } else if (x > width - outer_radius) {
                    x = width - outer_radius;
                    vx = -Math.abs(vx);
                    bounced = true;
                }
                
                if (y < outer_radius) {
                    y = outer_radius;
                    vy = Math.abs(vy);
                    bounced = true;
                } else if (y > height - outer_radius) {
                    y = height - outer_radius;
                    vy = -Math.abs(vy);
                    bounced = true;
                }
                
                // KEINE Offset-Variation - bleibt symmetrisch!
                
                // Friction anwenden
                vx *= friction;
                vy *= friction;
                
                // Rotation basiert auf Geschwindigkeit - SMOOTH!
                let speed = Math.sqrt(vx * vx + vy * vy);
                rotation_speed = (speed / dash_speed) * 0.20;  // War 0.15 ‚Üí jetzt 0.20 (smoother!)
                rotation += rotation_speed;
                
                // Zum Stillstand gekommen? (Nat√ºrliches Abbremsen!)
                if (speed < 0.5) {
                    // Wenn er gestolpert ist: Direkt zu on_ground (entt√§uscht)
                    if (fail_type === "stumbled") {
                        state = "on_ground";
                        fail_timer = 30;
                        squash_amount = 1.0;  // KEINE Form-√Ñnderung! ‚úÖ
                        vx = 0.0;
                        vy = 0.0;
                        trail_positions = [];
                    } else {
                        // Normal: Zur√ºck zu idle
                        state = "idle";
                        vx = 0.0;
                        vy = 0.0;
                        trail_positions = [];
                        target_outer = base_outer;
                        target_inner = base_inner;
                    }
                }
            }
            else if (state === "slipping") {
                // SLIP-FAIL: Schwindelig! Verliert Gleichgewicht!
                fail_timer++;
                
                // Bewegung mit WACKELIGER LINIE (schwindelig!)
                x += vx;
                y += vy;
                
                // SCHWINDEL-EFFEKT: Wackelige Bewegung!
                let dizzy_wobble_x = Math.sin(fail_timer * 0.3) * 3;  // Sinus-Welle horizontal
                let dizzy_wobble_y = Math.cos(fail_timer * 0.25) * 2.5;  // Cosinus-Welle vertikal
                x += dizzy_wobble_x;
                y += dizzy_wobble_y;
                
                // Trail
                if (frameCount % 2 === 0) {
                    trail_positions.push({
                        x: x,
                        y: y,
                        life: 15,
                        rotation: rotation
                    });
                }
                
                // Wand-Bounce (weicher)
                if (x < outer_radius || x > width - outer_radius) {
                    vx *= -0.7;
                }
                if (y < outer_radius || y > height - outer_radius) {
                    vy *= -0.7;
                }
                
                // Cartoon-Slip: Kippt zur Seite (nur am Anfang)
                if (fail_timer < 20) {
                    slip_offset += 0.08;
                    slip_offset = Math.min(slip_offset, HALF_PI);
                }
                
                // SMOOTHERE Friction: Gleitet aus
                let speed = Math.sqrt(vx * vx + vy * vy);
                
                if (fail_timer < 20) {
                    // Phase 1: Versucht zu bremsen (mehr Friction als vorher)
                    vx *= 0.96;
                    vy *= 0.96;
                } else {
                    // Phase 2: Bremst st√§rker ab
                    vx *= 0.90;
                    vy *= 0.90;
                }
                
                // Rotation schnell - SCHWINDELIG!
                rotation += 0.25;
                
                // Erst nach NAT√úRLICHEM Abbremsen UND genug Zeit: Zu spinning_down
                if (speed < 0.5 && fail_timer > 30) {  // KEIN abrupter Stopp! Wartet l√§nger!
                    state = "spinning_down";
                    fail_timer = 0;
                    // vx, vy BLEIBEN! (nicht auf 0 setzen - Momentum bleibt!)
                    squash_amount = 1.0;
                    trail_positions = [];
                }
            }
            else if (state === "on_ground") {
                // AUF DEM BODEN: Liegt - KEINE Form-√Ñnderung!
                fail_timer++;
                
                // Squash bleibt IMMER bei 1.0 (KEINE Form-√Ñnderung!)
                squash_amount = 1.0;
                
                // Schneller weiter - VIEL K√úRZER!
                if (fail_timer > 6) {  // 12 ‚Üí 6 (0.1 Sek)
                    state = "spinning_down";
                    fail_timer = 0;
                    squash_amount = 1.0;
                }
            }
            else if (state === "spinning_down") {
                // DREHT SICH AUS - kurz taumeln, dann an Ort und Stelle!
                fail_timer++;
                
                // Squash bleibt bei 1.0
                squash_amount = 1.0;
                
                // TAUMEL-PHASE nur kurz am Anfang! (erste 15 Frames = ~0.25 Sek) - SCHNELLER!
                if (fail_timer < 15) {  // War 18 ‚Üí jetzt 15! ‚úÖ
                    // TAUMELT wie Betrunkener!
                    let wobble_x = Math.sin(fail_timer * 0.15) * 4;
                    let wobble_y = Math.cos(fail_timer * 0.12) * 3.5;
                    
                    // Bewegt sich langsam PLUS Taumeln
                    vx *= 0.93;  // Noch schneller abbremsen: 0.95 ‚Üí 0.93
                    vy *= 0.93;
                    
                    x += vx + wobble_x;
                    y += vy + wobble_y;
                    
                    // Wand-Kollision (sanft)
                    if (x < outer_radius) {
                        x = outer_radius;
                        vx *= -0.5;
                    } else if (x > width - outer_radius) {
                        x = width - outer_radius;
                        vx *= -0.5;
                    }
                    
                    if (y < outer_radius) {
                        y = outer_radius;
                        vy *= -0.5;
                    } else if (y > height - outer_radius) {
                        y = height - outer_radius;
                        vy *= -0.5;
                    }
                } else {
                    // Nach 15 Frames: STEHT STILL, dreht sich nur noch aus!
                    vx = 0;
                    vy = 0;
                    // Nur Rotation, keine Bewegung mehr! ‚úÖ
                }
                
                // Rotation SMOOTH zu 0 bringen
                rotation_speed *= 0.97;
                rotation += rotation_speed;
                
                // Slip-Offset auch zur√ºck
                if (slip_offset > 0.01) {
                    slip_offset *= 0.95;
                }
                
                // Wenn ausgedreht: Aufstehen - VIEL SCHNELLER!
                if (Math.abs(rotation_speed) < 0.005 || fail_timer > 25) {  // 55 ‚Üí 25!
                    rotation_speed = 0.0;
                    slip_offset = 0.0;
                    vx = 0.0;
                    vy = 0.0;
                    state = "getting_up";
                    fail_timer = 0;
                }
            }
            else if (state === "getting_up") {
                // STEHT AUF - SCHNELLER!
                fail_timer++;
                
                // Squash bleibt bei 1.0
                squash_amount = 1.0;
                
                // VIEL SCHNELLER zu Shaking!
                if (fail_timer > 6) {  // 12 ‚Üí 6!
                    state = "shaking";
                    fail_timer = 0;
                    shake_start_rotation = rotation;  // Speichere aktuelle Rotation
                }
            }
            else if (state === "shaking") {
                // KOPF SCH√úTTELN - Rotation um eigene Achse, direkt aus aktueller Position!
                fail_timer++;
                
                // Shake-Intensit√§t: Schw√§cher aber schneller!
                let shakeIntensity = (1 - fail_timer / 30) * 5;  // 60 ‚Üí 30 (k√ºrzer!)
                
                // DIREKT SHAKEN um die Start-Rotation herum - SCHNELLER & H√ÑUFIGER!
                // Langsamere Frequenzen f√ºr h√§ufigeres aber gem√§chlicheres Wackeln
                let shake1 = Math.sin(fail_timer * 0.25) * shakeIntensity * 0.06;  // 0.40 ‚Üí 0.25 (langsamer!)
                let shake2 = Math.sin(fail_timer * 0.30) * shakeIntensity * 0.05;  // 0.50 ‚Üí 0.30
                let shake3 = Math.sin(fail_timer * 0.35) * shakeIntensity * 0.04;  // 0.60 ‚Üí 0.35
                let shake4 = Math.sin(fail_timer * 0.40) * shakeIntensity * 0.03;  // 0.70 ‚Üí 0.40
                let shake5 = Math.sin(fail_timer * 0.45) * shakeIntensity * 0.02;  // 0.80 ‚Üí 0.45
                let shakeAngle = shake1 + shake2 + shake3 + shake4 + shake5;
                rotation = shake_start_rotation + shakeAngle;  // Wackelt schnell um die Start-Position!
                
                // K√úRZER!
                if (fail_timer > 30) {  // 60 ‚Üí 30 (0.5 Sekunden)
                    rotation = shake_start_rotation;  // Zur√ºck zur Start-Position
                    state = "angry";
                    fail_timer = 0;
                }
            }
            else if (state === "angry") {
                // WUT - SCHNELLER!
                fail_timer++;
                
                // K√úRZER!
                if (fail_timer > 10) {  // 20 ‚Üí 10!
                    state = "pausing";
                    fail_timer = 0;
                }
            }
            else if (state === "pausing") {
                // PAUSE - SCHNELLER!
                fail_timer++;
                
                // K√úRZER!
                if (fail_timer > 15) {  // 30 ‚Üí 15! (0.25 Sek)
                    state = "idle";
                    state_timer = 0;
                    fail_type = null;
                    slip_offset = 0.0;
                    squash_amount = 1.0;
                }
            }
            
            // Morphing smooth anwenden
            outer_radius += (target_outer - outer_radius) * morph_speed;
            inner_radius += (target_inner - inner_radius) * morph_speed;
            
            // Trail-Partikel updaten
            trail_positions = trail_positions.filter(p => p.life > 0);
            for (let p of trail_positions) {
                p.life--;
            }
            
            // Rotation ausdrehen wenn idle
            if (state === "idle") {
                rotation_speed *= 0.96;
                rotation += rotation_speed;
                if (Math.abs(rotation_speed) < 0.005) {
                    rotation_speed = 0.0;
                }
            }
        }

        function startCharging() {
            state = "charging";
            state_timer = 0;
            // MINIMALES Morphing - nur leicht gr√∂√üer!
            target_outer = random(32, 35);  // War 45-52 ‚Üí jetzt 32-35 (nur +2 bis +5!)
            target_inner = random(11, 13);  // War 13-17 ‚Üí jetzt 11-13 (nur -1 bis +1!)
        }

        function startDash() {
            trail_positions = [];
            
            // FAIL-CHECK: 25% Stumble, 25% Slip (50% TOTAL)
            let fail_roll = random();
            
            if (fail_roll < 0.25) {
                // STUMBLE-FAIL
                state = "dashing";
                fail_type = "stumble";
                fail_timer = floor(random(10, 25));
            }
            else if (fail_roll < 0.50) {
                // SLIP-FAIL
                state = "slipping";
                fail_type = "slip";
                fail_timer = 0;
                slip_offset = 0.0;
            }
            else {
                // NORMALER DASH (50%)
                state = "dashing";
                fail_type = null;
            }
            
            // Richtung zur Maus berechnen
            let dx = mouseX - x;
            let dy = mouseY - y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                if (fail_type === "stumble") {
                    // SEHR falsche Richtung! (60-90 Grad Abweichung - definitiv falsch!)
                    let angle_offset = random(-1.2, 1.2);  // -0.5 ‚Üí 1.2 (viel gr√∂√üer!)
                    let angle = Math.atan2(dy, dx) + angle_offset;
                    vx = Math.cos(angle) * dash_speed;
                    vy = Math.sin(angle) * dash_speed;
                    fail_direction = angle_offset;
                }
                else if (fail_type === "slip") {
                    // Zu schnell! 160% Speed (proportional zu h√∂herer dash_speed)
                    vx = (dx / dist) * dash_speed * 1.6;
                    vy = (dy / dist) * dash_speed * 1.6;
                }
                else {
                    // Normal
                    vx = (dx / dist) * dash_speed;
                    vy = (dy / dist) * dash_speed;
                }
            }
            
            // Zur√ºck zur normalen Gr√∂√üe beim Dash
            target_outer = base_outer;
            target_inner = base_inner;
        }

        function drawStarShape(px, py, rot, alpha = 255) {
            push();
            translate(px, py);
            rotate(rot);
            
            // Squash-Effekt anwenden
            scale(1.0, squash_amount);
            
            // Flash-Farbe: CRIMSON RED (#DC143C)
            fill(220, 20, 60, alpha);
            noStroke();
            
            // 4-Zacken Stern mit SEHR RUNDEN Kurven (bezierVertex!)
            beginShape();
            
            // Berechne alle Punkte zuerst
            let star_points = [];
            for (let i = 0; i < points * 2; i++) {
                let angle = i * PI / points - HALF_PI;
                let is_outer = (i % 2 === 0);
                let r = is_outer ? outer_radius : inner_radius;
                r += offsets[i] || 0;
                star_points.push({
                    x: Math.cos(angle) * r,
                    y: Math.sin(angle) * r
                });
            }
            
            // Start
            vertex(star_points[0].x, star_points[0].y);
            
            // Zeichne mit bezierVertex (ZWEI Control Points f√ºr starke Rundung!)
            for (let i = 1; i < star_points.length; i++) {
                let prev = star_points[i - 1];
                let curr = star_points[i];
                
                // ZWEI Control Points f√ºr smooth cubic bezier!
                let ctrl1_x = lerp(prev.x, curr.x, 0.4);  // Erster bei 40%
                let ctrl1_y = lerp(prev.y, curr.y, 0.4);
                
                let ctrl2_x = lerp(prev.x, curr.x, 0.6);  // Zweiter bei 60%
                let ctrl2_y = lerp(prev.y, curr.y, 0.6);
                
                bezierVertex(ctrl1_x, ctrl1_y, ctrl2_x, ctrl2_y, curr.x, curr.y);
            }
            
            // Schlie√üe Kurve zum Anfang
            let last = star_points[star_points.length - 1];
            let first = star_points[0];
            let ctrl1_x = lerp(last.x, first.x, 0.4);
            let ctrl1_y = lerp(last.y, first.y, 0.4);
            let ctrl2_x = lerp(last.x, first.x, 0.6);
            let ctrl2_y = lerp(last.y, first.y, 0.6);
            bezierVertex(ctrl1_x, ctrl1_y, ctrl2_x, ctrl2_y, first.x, first.y);
            
            endShape(CLOSE);
            pop();
        }

        function displayFlash() {
            // Trail zeichnen (helle gelbe Blitz-Silhouetten)
            for (let p of trail_positions) {
                let alpha = (p.life / 15) * 180;  // Etwas transparenter
                
                push();
                translate(p.x, p.y);
                rotate(p.rotation);
                scale(1.0, squash_amount);
                
                // HELLES GELB f√ºr Blitz-Trail (#FFE55C)
                fill(255, 229, 92, alpha);
                noStroke();
                
                // Kleinere Trail-Sterne (70%)
                let trail_outer = outer_radius * 0.7;
                let trail_inner = inner_radius * 0.7;
                
                beginShape();
                for (let i = 0; i < points * 2; i++) {
                    let angle = i * PI / points - HALF_PI;
                    let r = (i % 2 === 0) ? trail_outer : trail_inner;
                    r += offsets[i] * 0.7;
                    
                    let vx_point = Math.cos(angle) * r;
                    let vy_point = Math.sin(angle) * r;
                    vertex(vx_point, vy_point);
                }
                endShape(CLOSE);
                pop();
            }
            
            // FAIL-EFFEKTE anwenden
            let display_x = x;
            let display_y = y;
            let extra_rotation = 0.0;
            
            // Slip-Offset (Cartoon-Kippung)
            if (state === "slipping" || state === "on_ground") {
                extra_rotation = slip_offset;
            }
            
            // Haupt-Stern zeichnen
            // Shake-Effekt wird jetzt direkt √ºber rotation gesteuert (in updateFlash)
            drawStarShape(display_x, display_y, rotation + extra_rotation);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>