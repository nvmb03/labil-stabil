<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superman | Labil–Stabil</title>
    
    <!-- p5.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        if (typeof p5 === 'undefined') {
            document.write('<script src="p5.min.js"><\/script>');
        }
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Chicago&family=VT323&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --retro-panel: #FFFFFF;
            --retro-border: #000000;
            --retro-shadow: rgba(0, 0, 0, 0.35);
            --retro-shadow-strong: rgba(0, 0, 0, 0.5);
            --retro-text: #111111;
            --accent: #4A90E2;
            --accent-dark: #193882;
        }

        body {
            font-family: 'Space Mono', 'Chicago', 'VT323', monospace;
            background: #F5F7FB;  /* Sehr helles Blau */
            color: var(--retro-text);
            overflow: hidden;
            touch-action: manipulation;
        }
        canvas {
            display: block;
        }
        
        /* Icons */
        .icon-button {
            position: fixed;
            width: 44px;
            height: 44px;
            background: var(--retro-panel);
            border: 2px solid var(--retro-border);
            color: var(--retro-text);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
            z-index: 1000;
            text-decoration: none;
            box-shadow: 4px 4px 0 var(--retro-shadow);
        }
        
        .icon-button:hover {
            background: #000;
            color: #fff;
            transform: translateY(-1px);
            box-shadow: 6px 6px 0 var(--retro-shadow-strong);
        }
        
        #backButton {
            top: 20px;
            left: 20px;
        }
        
        #infoButton {
            top: 20px;
            right: 20px;
        }
        
        /* Info Panel */
        #infoPanel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 360px;
            max-height: calc(100vh - 120px);
            background: var(--retro-panel);
            border: 2px solid var(--retro-border);
            box-shadow: 6px 6px 0 var(--retro-shadow);
            color: var(--retro-text);
            z-index: 999;
            overflow: hidden;
            transform: translateX(420px);
            opacity: 0;
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #infoPanel.active {
            transform: translateX(0);
            opacity: 1;
        }
        
        .panel-titlebar {
            height: 26px;
            background: linear-gradient(180deg, var(--accent) 0%, var(--accent-dark) 100%);
            border-bottom: 2px solid var(--retro-border);
            display: flex;
            align-items: center;
            padding: 0 8px;
        }

        .panel-title {
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1.2px;
            text-align: center;
            flex: 1;
            color: #fff;
        }

        .panel-content {
            padding: 18px 20px 22px;
            overflow-y: auto;
            max-height: calc(100vh - 170px);
        }
        
        #infoPanel h2 {
            font-size: 13px;
            margin-top: 16px;
            margin-bottom: 8px;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #infoPanel p {
            font-size: 13px;
            line-height: 1.7;
            opacity: 0.95;
            margin-bottom: 12px;
        }
        
        #infoPanel strong {
            color: #000;
        }
        
        #infoPanel ul {
            list-style: none;
            padding-left: 0;
        }
        
        #infoPanel li {
            font-size: 12px;
            line-height: 1.6;
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
            opacity: 0.9;
        }
        
        #infoPanel li:before {
            content: "→";
            position: absolute;
            left: 0;
            color: #000;
        }
        
        /* Scrollbar styling */
        .panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .panel-content::-webkit-scrollbar-track {
            background: #EFEFEF;
        }

        .panel-content::-webkit-scrollbar-thumb {
            background: #000;
            border-radius: 3px;
        }


    </style>
</head>
<body>
    <!-- Back Button -->
    <a href="index.html" class="icon-button" id="backButton">←</a>
    
    <!-- Info Button -->
    <div class="icon-button" id="infoButton">i</div>
    
    <!-- Info Panel -->
    <div id="infoPanel">
        <div class="panel-titlebar">
            <div class="panel-title">SUPERMAN</div>
        </div>
        <div class="panel-content">
            <h2>Stabil</h2>
            <p>Superman fliegt elegant durch den Himmel. Vollständige Kontrolle, präzise Bewegungen – er folgt der Maus sanft und elegant. Das Cape weht sanft im Wind.</p>
            
            <h2>Labil: Neurodivergenz (ADHS/Hyperfokus)</h2>
            <p>Plötzlich, ohne Vorwarnung: Der Hyperfokus aktiviert sich. Superman wird schneller, stärker, präziser – seine Superkraft erreicht ihr Maximum. Der Fokus ist extrem und bringt Klarheit auf das Wesentliche. Bewegungen werden intensiver und direkter, als würde er in eine eigene Spur wechseln, in der alles möglich wirkt.</p>
            
            <h2>Die Stärke – und Balance</h2>
            <p>Supermans Neurodivergenz ist ein Verstärker. Im Hyperfokus entstehen außergewöhnliche Konzentration, Mut und Ausdauer. Manchmal braucht es ein Innehalten, um die Kraft wieder fein zu steuern – doch genau darin wächst seine besondere Stärke. Und wenn die Steuerung kurz entgleitet, findet er seine Linie neu und bleibt im Flug.</p>
        </div>
    </div>

    <script>
        // p5.js Sketch
        let star;
        let clouds = [];
        let cloudParticles = [];
        let pendingCloudSpawns = [];  // Geplante Wolken-Spawns
        
        class CloudSpawnEvent {
            constructor() {
                this.delay = random(60, 180);  // 1-3 Sekunden bei 60 FPS
                this.timeRemaining = this.delay;
            }
            
            update() {
                this.timeRemaining--;
                return this.timeRemaining <= 0;
            }
        }
        
        class CloudParticle {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.size = random(8, 15);
                this.maxSize = this.size;
                this.life = 1.0;
                this.decay = random(0.015, 0.025);
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1;  // Schwerkraft
                this.life -= this.decay;
                this.size = this.maxSize * this.life;
            }
            
            display() {
                push();
                fill(255, 255, 255, 200 * this.life);
                noStroke();
                circle(this.x, this.y, this.size);
                pop();
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        class Cloud {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.speed = random(0.2, 0.8);
                this.type = floor(random(5));  // 5 unterschiedliche asymmetrische Wolkentypen
                this.isDissolving = false;
                this.dissolveProgress = 0;
                // Zufällige kleine Offsets für extra Variation
                this.randomOffsets = {
                    top: random(-5, 8),
                    left: random(-6, 6),
                    right: random(-6, 6),
                    bottom: random(-5, 8)
                };
            }
            
            update() {
                if (!this.isDissolving) {
                    this.x += this.speed;
                    // Wolken wrappen am Bildschirmrand
                    if (this.x > width + 100) {
                        this.x = -100;
                    }
                }
            }
            
            checkCollision(starX, starY, starSize) {
                let distance = dist(this.x, this.y, starX, starY);
                return distance < this.size + starSize;
            }
            
            dissolve() {
                if (!this.isDissolving) {
                    this.isDissolving = true;
                    // Erstelle Partikel
                    let particleCount = random(8, 15);
                    for (let i = 0; i < particleCount; i++) {
                        let angle = random(TWO_PI);
                        let speed = random(2, 5);
                        let vx = cos(angle) * speed;
                        let vy = sin(angle) * speed - 2;  // Nach oben impulse
                        cloudParticles.push(new CloudParticle(this.x, this.y, vx, vy));
                    }
                    
                    // Plane das Spawning einer neuen Wolke
                    pendingCloudSpawns.push(new CloudSpawnEvent());
                }
            }
            
            display() {
                if (this.isDissolving) {
                    return;  // Nicht zeichnen wenn aufgelöst
                }
                
                push();
                fill(255, 255, 255, 220);
                noStroke();
                
                let cx = this.x;
                let cy = this.y;
                let s = this.size;
                
                // Verschiedene Wolkentypen - asymmetrisch mit größeren Kugeln
                if (this.type === 0) {
                    // Große fluffige Wolke
                    circle(cx - s * 0.7, cy + this.randomOffsets.left * 0.05, s * 0.7);
                    circle(cx - s * 0.2, cy - s * 0.5 + this.randomOffsets.top * 0.03, s * 0.9);
                    circle(cx + s * 0.5, cy - s * 0.35 + this.randomOffsets.top * 0.04, s * 0.85);
                    circle(cx + s * 0.95, cy + this.randomOffsets.right * 0.05, s * 0.65);
                    circle(cx + s * 0.05, cy + s * 0.4 + this.randomOffsets.bottom * 0.03, s * 0.75);
                    
                } else if (this.type === 1) {
                    // Breite Wolke mit Wölbung - rechts unten ausgebeult
                    circle(cx - s * 0.8, cy + s * 0.2, s * 0.65);
                    circle(cx - s * 0.25, cy - s * 0.4, s * 0.8);
                    circle(cx + s * 0.15, cy - s * 0.6, s * 0.9);
                    circle(cx + s * 0.6, cy - s * 0.2, s * 0.75);
                    circle(cx + s * 1.05, cy + s * 0.35, s * 0.75);
                    circle(cx + s * 0.15, cy + s * 0.5, s * 0.65);
                    
                } else if (this.type === 2) {
                    // Kleine kugelige Wolke - asymmetrisch
                    circle(cx - s * 0.35, cy + s * 0.1, s * 0.6);
                    circle(cx, cy - s * 0.45, s * 0.75);
                    circle(cx + s * 0.55, cy - s * 0.1, s * 0.65);
                    circle(cx - s * 0.2, cy + s * 0.35, s * 0.55);
                    circle(cx + s * 0.4, cy + s * 0.3, s * 0.6);
                    
                } else if (this.type === 3) {
                    // Wolke mit oben-links Beule
                    circle(cx - s * 0.75, cy - s * 0.5, s * 0.85);
                    circle(cx - s * 0.1, cy - s * 0.55, s * 0.9);
                    circle(cx + s * 0.4, cy - s * 0.25, s * 0.75);
                    circle(cx + s * 0.85, cy + s * 0.05, s * 0.65);
                    circle(cx, cy + s * 0.4, s * 0.7);
                    circle(cx - s * 0.5, cy + s * 0.25, s * 0.65);
                    
                } else {
                    // Breite asymmetrische Wolke - links ausgebeult
                    circle(cx - s * 1.05, cy - s * 0.05, s * 0.75);
                    circle(cx - s * 0.45, cy - s * 0.45, s * 0.85);
                    circle(cx + s * 0.05, cy - s * 0.55, s * 0.9);
                    circle(cx + s * 0.5, cy - s * 0.15, s * 0.7);
                    circle(cx + s * 0.8, cy + s * 0.2, s * 0.65);
                    circle(cx - s * 0.15, cy + s * 0.45, s * 0.65);
                }
                
                pop();
            }
        }
        
        class SupermanStar {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.size = 35;
                
                // Stop-Distanz
                this.stopDistance = 80;
                
                // Idle-Mechanik
                this.idleTime = 0;
                this.idleThreshold = 10;  // Frames bis idle (erhöht: 1 → 10)
                this.isIdle = false;
                
                // Schwebe-Animation
                this.hoverOffset = 0;
                
                // Geschwindigkeits-Tracking
                this.velocity = 0;
                this.lastX = x;
                this.lastY = y;
                
                // Momentum
                this.vx = 0;
                this.vy = 0;
                
                // ========== HYPERFOKUS-CRASH STATE MACHINE ==========
                this.state = 'normal';  // normal | hyperfocus | crashed | shaking
                
                // Hyperfokus
                this.hyperfocusTarget = { x: 0, y: 0 };
                this.hyperfocusChance = 0.0035;  // 0.35% pro Frame (~alle 5 Sekunden)
                
                // Crash
                this.crashRotation = 0;
                this.crashRotationSpeed = 0;
                
                // Shaking
                this.shakeTimer = 0;
                this.shakeDuration = 60;  // 1 Sekunde bei 60 FPS
                this.shakeIntensity = 0;
                
                // Recovery
                this.justRecovered = false;
                this.recoveryFrames = 0;
            }
            
            update(targetX, targetY) {
                // ========== STATE MACHINE ==========
                
                if (this.state === 'normal') {
                    this.updateNormal(targetX, targetY);
                    
                    // Random Hyperfokus-Trigger NUR wenn NICHT idle!
                    if (!this.isIdle && random() < this.hyperfocusChance) {
                        this.triggerHyperfocus(targetX, targetY);
                    }
                    
                } else if (this.state === 'hyperfocus') {
                    this.updateHyperfocus();
                    
                } else if (this.state === 'crashed') {
                    this.updateCrashed();
                    
                } else if (this.state === 'shaking') {
                    this.updateShaking();
                }
                
                // Geschwindigkeit berechnen
                this.velocity = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            }
            
            // ========== NORMAL STATE ==========
            updateNormal(targetX, targetY) {
                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                
                let isMoving = false;
                
                // Sanfter Start nach Recovery (erste 30 Frames)
                if (this.justRecovered) {
                    this.recoveryFrames++;
                    if (this.recoveryFrames >= 30) {
                        this.justRecovered = false;
                        this.recoveryFrames = 0;
                    }
                }
                
                if (dist > this.stopDistance) {
                    // Normale Bewegung - aber sanfter Start nach Recovery!
                    let easing = 0.05;
                    
                    // Reduziere Easing in den ersten 30 Frames nach Recovery
                    if (this.justRecovered) {
                        let recoveryProgress = this.recoveryFrames / 30;
                        easing = 0.01 + (0.04 * recoveryProgress);  // Rampe von 0.01 → 0.05
                    }
                    
                    let moveX = dx * easing;
                    let moveY = dy * easing;
                    
                    this.x += moveX;
                    this.y += moveY;
                    
                    this.vx = moveX;
                    this.vy = moveY;
                    isMoving = true;
                } else {
                    let brakeFactor = this.isIdle ? 0.5 : 0.85;
                    this.vx *= brakeFactor;
                    this.vy *= brakeFactor;
                    
                    if (Math.abs(this.vx) > 0.02 || Math.abs(this.vy) > 0.02) {
                        this.x += this.vx;
                        this.y += this.vy;
                    } else {
                        this.vx = 0;
                        this.vy = 0;
                    }
                    
                    if (this.isIdle && dist > this.stopDistance - 10) {
                        this.x += dx * 0.005;
                        this.y += dy * 0.005;
                    }
                }
                
                // Idle-Mechanik
                if (isMoving || dist > this.stopDistance + 10) {
                    this.idleTime = 0;
                    this.isIdle = false;
                } else {
                    this.idleTime++;
                    if (this.idleTime > this.idleThreshold) {
                        this.isIdle = true;
                    }
                }
                
                // Rotation
                let targetAngle = this.isIdle ? PI : Math.atan2(dy, dx) - HALF_PI;
                
                let angleDiff = targetAngle - this.angle;
                while (angleDiff > PI) angleDiff -= TWO_PI;
                while (angleDiff < -PI) angleDiff += TWO_PI;
                
                let rotationSpeed = this.isIdle ? 0.045 : 0.12;
                this.angle += angleDiff * rotationSpeed;
                
                // Schwebe-Animation
                let targetHoverOffset = this.isIdle ? Math.sin(frameCount * 0.06) * 8 : 0;
                this.hoverOffset += (targetHoverOffset - this.hoverOffset) * 0.1;
            }
            
            // ========== HYPERFOKUS TRIGGER ==========
            triggerHyperfocus(targetX, targetY) {
                this.state = 'hyperfocus';
                
                // Berechne Richtung zur Maus
                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    // Normalisiere Richtung
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    
                    // Finde Schnittpunkt mit Bildschirmrand in dieser Richtung
                    let t_values = [];
                    
                    if (dirX > 0) {
                        t_values.push((width - this.x) / dirX);
                    } else if (dirX < 0) {
                        t_values.push(-this.x / dirX);
                    }
                    
                    if (dirY > 0) {
                        t_values.push((height - this.y) / dirY);
                    } else if (dirY < 0) {
                        t_values.push(-this.y / dirY);
                    }
                    
                    // Finde nächsten Rand
                    let t_min = Math.min(...t_values.filter(t => t > 0));
                    
                    // Ziel ist jetzt IMMER am Bildschirmrand!
                    this.hyperfocusTarget.x = this.x + dirX * t_min;
                    this.hyperfocusTarget.y = this.y + dirY * t_min;
                    
                    // Setze Geschwindigkeit (doppelt so schnell!)
                    this.vx = dirX * 10;
                    this.vy = dirY * 10;
                }
                
                this.isIdle = false;
                this.idleTime = 0;
            }
            
            // ========== HYPERFOKUS STATE ==========
            updateHyperfocus() {
                // Ignoriere Maus komplett! Fliege stur zum gespeicherten Ziel
                
                // Beschleunige weiter in Richtung fixiertes Ziel
                let dx = this.hyperfocusTarget.x - this.x;
                let dy = this.hyperfocusTarget.y - this.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    // Weiter beschleunigen (Tunnel-Vision!)
                    let acceleration = 0.3;
                    this.vx += (dx / dist) * acceleration;
                    this.vy += (dy / dist) * acceleration;
                }
                
                // Bewege Stern
                this.x += this.vx;
                this.y += this.vy;
                
                // Rotation zur Flugrichtung
                let targetAngle = Math.atan2(this.vy, this.vx) - HALF_PI;
                let angleDiff = targetAngle - this.angle;
                while (angleDiff > PI) angleDiff -= TWO_PI;
                while (angleDiff < -PI) angleDiff += TWO_PI;
                this.angle += angleDiff * 0.2;
                
                // Check Wand-Kollision
                let margin = this.size;
                let hitWall = false;
                
                if (this.x <= margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.6;  // Bounce nach rechts
                    hitWall = true;
                } else if (this.x >= width - margin) {
                    this.x = width - margin;
                    this.vx = -Math.abs(this.vx) * 0.6;  // Bounce nach links
                    hitWall = true;
                }
                
                if (this.y <= margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.6;  // Bounce nach unten
                    hitWall = true;
                } else if (this.y >= height - margin) {
                    this.y = height - margin;
                    this.vy = -Math.abs(this.vy) * 0.6;  // Bounce nach oben
                    hitWall = true;
                }
                
                if (hitWall) {
                    // CRASH! Übergang zu crashed state
                    this.state = 'crashed';
                    this.crashRotation = this.angle;
                    this.crashRotationSpeed = random(0.15, 0.3) * (random() > 0.5 ? 1 : -1);
                }
            }
            
            // ========== CRASHED STATE ==========
            updateCrashed() {
                // Physikalisches Abbremsen nach Crash
                this.vx *= 0.92;
                this.vy *= 0.92;
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Taumelnde Rotation
                this.crashRotation += this.crashRotationSpeed;
                this.crashRotationSpeed *= 0.95;
                this.angle = this.crashRotation;
                
                // Wenn fast stillsteht → Shaking
                if (Math.abs(this.vx) < 0.5 && Math.abs(this.vy) < 0.5) {
                    this.state = 'shaking';
                    this.shakeTimer = 0;
                    this.vx = 0;
                    this.vy = 0;
                }
            }
            
            // ========== SHAKING STATE ==========
            updateShaking() {
                this.shakeTimer++;
                
                // Shake-Intensität: Stark am Anfang, nimmt ab - INTENSIVER!
                this.shakeIntensity = (1 - this.shakeTimer / this.shakeDuration) * 5;  // 3 → 5 (stärker!)
                
                // SMOOTH TRANSITION: Drehe sanft zur aufrechten Position (PI)
                // In den ersten 20 Frames: Rotation von crashed-Winkel zu PI (langsamer: 15 → 20)
                if (this.shakeTimer <= 20) {
                    let transitionProgress = this.shakeTimer / 20;
                    // Smooth easing
                    let easedProgress = transitionProgress * transitionProgress * (3 - 2 * transitionProgress); // Smoothstep
                    
                    // Interpoliere von crashRotation zu PI
                    let targetAngle = PI;
                    let angleDiff = targetAngle - this.crashRotation;
                    
                    // Normalisiere Winkel-Differenz
                    while (angleDiff > PI) angleDiff -= TWO_PI;
                    while (angleDiff < -PI) angleDiff += TWO_PI;
                    
                    this.angle = this.crashRotation + angleDiff * easedProgress;
                } else {
                    // Nach Transition: Normale Wackel-Animation - STÄRKER!
                    // Mehrere Sinus-Wellen überlagert für organische Bewegung
                    let shake1 = Math.sin(this.shakeTimer * 0.3) * this.shakeIntensity * 0.05;  // 0.03 → 0.05
                    let shake2 = Math.sin(this.shakeTimer * 0.5) * this.shakeIntensity * 0.03;  // 0.02 → 0.03
                    let shakeAngle = shake1 + shake2;
                    this.angle = PI + shakeAngle;  // Aufrecht + stärkeres Wackeln
                }
                
                if (this.shakeTimer >= this.shakeDuration) {
                    // Recovery! Zurück zu normal
                    this.state = 'normal';
                    this.shakeTimer = 0;
                    this.shakeIntensity = 0;
                    this.angle = PI;  // Aufrecht
                    
                    // WICHTIG: Starte im Idle, aber mit Reset-Flag!
                    this.isIdle = true;
                    this.justRecovered = true;  // Neues Flag für sanften Start
                    
                    // Geschwindigkeit auf 0 setzen!
                    this.vx = 0;
                    this.vy = 0;
                }
            }
            
            drawStar() {
                beginShape();
                for (let i = 0; i < 10; i++) {
                    let angle = TWO_PI / 10 * i + TWO_PI / 20;
                    let r = (i % 2 === 0) ? this.size : this.size * 0.4;
                    let vx = Math.cos(angle) * r;
                    let vy = Math.sin(angle) * r;
                    vertex(vx, vy);
                }
                endShape(CLOSE);
            }
            
            drawCape() {
                // Cape-Physik basierend auf State
                let baseWaveIntensity = 4;
                let baseWaveSpeed = 0.06;
                let baseGravity = 6;
                
                // ========== HYPERFOKUS: EXTREMES FLATTERN! ==========
                if (this.state === 'hyperfocus') {
                    // Doppelte Intensität + schnellere Wellen!
                    baseWaveIntensity = 12;
                    baseWaveSpeed = 0.15;
                    baseGravity = 2;  // Cape wird vom Wind nach hinten gerissen
                }
                // ========== CRASHED/SHAKING: Schlaff ==========
                else if (this.state === 'crashed' || this.state === 'shaking') {
                    baseWaveIntensity = 1;
                    baseWaveSpeed = 0.03;
                    baseGravity = 10;  // Hängt schwer
                }
                // ========== NORMAL ==========
                else {
                    if (this.isIdle) {
                        this.capeVelocityFactor = 0;
                    } else {
                        let targetVelocityFactor = Math.min(this.velocity * 3, 1);
                        if (!this.capeVelocityFactor) this.capeVelocityFactor = 0;
                        this.capeVelocityFactor += (targetVelocityFactor - this.capeVelocityFactor) * 0.15;
                    }
                    
                    baseWaveIntensity += this.capeVelocityFactor * 4;
                    baseWaveSpeed += this.capeVelocityFactor * 0.04;
                    baseGravity -= this.capeVelocityFactor * 3;
                }
                
                let wave1 = Math.sin(frameCount * baseWaveSpeed) * baseWaveIntensity;
                let wave2 = Math.sin(frameCount * baseWaveSpeed + 1) * baseWaveIntensity * 0.7;
                let wave3 = Math.sin(frameCount * baseWaveSpeed + 2) * baseWaveIntensity * 0.5;
                
                fill(220, 38, 38);
                noStroke();
                
                beginShape();
                vertex(-20, 0);
                vertex(-30 + wave1 * 0.3, 20 + baseGravity * 0.2);
                vertex(-40 + wave1 * 0.6, 40 + baseGravity * 0.4);
                vertex(-45 + wave2 * 0.8, 60 + baseGravity * 0.6);
                vertex(-40 + wave3, 80 + baseGravity * 0.8);
                vertex(-20 + wave3 * 0.5, 70 + baseGravity * 0.9);
                vertex(0 + wave3 * 0.3, 75 + baseGravity);
                vertex(20 + wave3 * 0.5, 70 + baseGravity * 0.9);
                vertex(40 + wave3, 80 + baseGravity * 0.8);
                vertex(45 + wave2 * 0.8, 60 + baseGravity * 0.6);
                vertex(40 + wave1 * 0.6, 40 + baseGravity * 0.4);
                vertex(30 + wave1 * 0.3, 20 + baseGravity * 0.2);
                vertex(20, 0);
                endShape(CLOSE);
            }
            
            display() {
                push();
                
                // Shaking: Position wackelt auch - SMOOTHER!
                let shakeX = 0, shakeY = 0;
                if (this.state === 'shaking') {
                    // Sanftere Sinus-basierte Bewegung statt random
                    shakeX = Math.sin(this.shakeTimer * 0.4) * this.shakeIntensity;
                    shakeY = Math.cos(this.shakeTimer * 0.35) * this.shakeIntensity;
                }
                
                translate(this.x + shakeX, this.y + this.hoverOffset + shakeY);
                
                // Cape ZUERST (hinten)
                push();
                rotate(this.angle + PI);
                this.drawCape();
                pop();
                
                // Stern DARÜBER (vorne)
                push();
                rotate(this.angle);
                fill(25, 56, 130);
                noStroke();
                this.drawStar();
                pop();
                
                pop();
            }
        }
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            star = new SupermanStar(width / 2, height / 2);
            
            // Wolken erstellen - zufällig auf dem Screen beim Start
            for (let i = 0; i < 7; i++) {
                let x = random(width);
                let y = random(height * 0.15, height * 0.65);
                let size = random(30, 60);
                clouds.push(new Cloud(x, y, size));
            }
        }
        
        function draw() {
            // Himmel-Gradient: Oben dunkelblau, unten hellweiß
            for (let y = 0; y < height; y++) {
                let inter = map(y, 0, height, 0, 1);
                let r = lerp(100, 220, inter);
                let g = lerp(170, 240, inter);
                let b = lerp(230, 255, inter);
                stroke(r, g, b);
                line(0, y, width, y);
            }
            noStroke();
            
            // Geplante Wolken-Spawns verarbeiten
            for (let i = pendingCloudSpawns.length - 1; i >= 0; i--) {
                if (pendingCloudSpawns[i].update()) {
                    // Spawn neue Wolke von links
                    let x = -100;  // Weit links außerhalb des Bildschirms
                    let y = random(height * 0.15, height * 0.65);
                    let size = random(30, 60);
                    clouds.push(new Cloud(x, y, size));
                    
                    pendingCloudSpawns.splice(i, 1);
                }
            }
            
            // Wolken updaten und auf Kollision prüfen
            for (let i = clouds.length - 1; i >= 0; i--) {
                clouds[i].update();
                
                // Kollisionserkennung mit Superman
                if (clouds[i].checkCollision(star.x, star.y, star.size)) {
                    clouds[i].dissolve();
                }
                
                // Entferne aufgelöste Wolken
                if (clouds[i].isDissolving) {
                    clouds.splice(i, 1);
                } else {
                    clouds[i].display();
                }
            }
            
            // Wolkenpartikel zeichnen und updaten
            for (let i = cloudParticles.length - 1; i >= 0; i--) {
                cloudParticles[i].update();
                cloudParticles[i].display();
                
                // Entferne tote Partikel
                if (cloudParticles[i].isDead()) {
                    cloudParticles.splice(i, 1);
                }
            }
            
            star.update(mouseX, mouseY);
            star.display();
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>

    <script>
        // Info Panel Toggle
        const infoButton = document.getElementById('infoButton');
        const infoPanel = document.getElementById('infoPanel');
        
        infoButton.addEventListener('click', () => {
            infoPanel.classList.toggle('active');
        });
        
        document.addEventListener('click', (e) => {
            if (!infoPanel.contains(e.target) && e.target !== infoButton) {
                infoPanel.classList.remove('active');
            }
        });
    </script>
</body>
</html>